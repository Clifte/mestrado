
\documentclass[
	% -- opções da classe memoir --
	article,			% indica que é um artigo acadêmico
	11pt,				% tamanho da fonte
	oneside,			% para impressão apenas no verso. Oposto a twoside
	a4paper,			% tamanho do papel. 
	% -- opções da classe abntex2 --
	%chapter=TITLE,		% títulos de capítulos convertidos em letras maiúsculas
	%section=TITLE,		% títulos de seções convertidos em letras maiúsculas
	%subsection=TITLE,	% títulos de subseções convertidos em letras maiúsculas
	%subsubsection=TITLE % títulos de subsubseções convertidos em letras maiúsculas
	% -- opções do pacote babel --
	english,			% idioma adicional para hifenização
	brazil,				% o último idioma é o principal do documento
	sumario=tradicional
	]{abntex2}

\newcommand{\matlabCodePath}{/home/clifte/git/Mestrado/Matlab/}
% ---
% PACOTES
% ---

% ---
% Pacotes fundamentais 
% ---
\usepackage{lmodern}			% Usa a fonte Latin Modern
\usepackage[T1]{fontenc}		% Selecao de codigos de fonte.
\usepackage[utf8]{inputenc}		% Codificacao do documento (conversão automática dos acentos)
\usepackage{indentfirst}		% Indenta o primeiro parágrafo de cada seção.
\usepackage{nomencl} 			% Lista de simbolos
\usepackage{color}				% Controle das cores
\usepackage{graphicx}			% Inclusão de gráficos
\usepackage{microtype} 			% para melhorias de justificação

\usepackage{amsmath} 			% Equações
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{tikz}
\usepackage{listings}
\usepackage[]{mcode}
\usepackage{listingsutf8}
\usepackage{epstopdf}
% ---
		
% ---
% Pacotes adicionais, usados apenas no âmbito do Modelo Canônico do abnteX2
% ---
\usepackage{lipsum}				% para geração de dummy text
% ---
		
% ---
% Pacotes de citações
% ---
\usepackage[brazilian,hyperpageref]{backref}	 % Paginas com as citações na bibl
\usepackage[alf]{abntex2cite}	% Citações padrão ABNT


% ---

% ---
% Configurações do pacote backref
% Usado sem a opção hyperpageref de backref
\renewcommand{\backrefpagesname}{Citado na(s) página(s):~}
% Texto padrão antes do número das páginas
\renewcommand{\backref}{}
% Define os textos da citação
\renewcommand*{\backrefalt}[4]{
	\ifcase #1 %
		Nenhuma citação no texto.%
	\or
		Citado na página #2.%
	\else
		Citado #1 vezes nas páginas #2.%
	\fi}%
% ---

% ---
% Informações de dados para CAPA e FOLHA DE ROSTO
% ---
\titulo{Relatório de Trabalho 2}
\autor{David Clifte da Silva Vieira}
\local{Brasil}
\data{2014, 21 de outubro}
% ---

% ---
% Configurações de aparência do PDF final

% alterando o aspecto da cor azul
\definecolor{blue}{RGB}{41,5,195}

% informações do PDF
\makeatletter
\hypersetup{
     	%pagebackref=true,
		pdftitle={\@title}, 
		pdfauthor={\@author},
    	pdfsubject={Modelo de artigo científico com abnTeX2},
	    pdfcreator={LaTeX with abnTeX2},
		pdfkeywords={abnt}{latex}{abntex}{abntex2}{atigo científico}, 
		colorlinks=true,       		% false: boxed links; true: colored links
    	linkcolor=blue,          	% color of internal links
    	citecolor=blue,        		% color of links to bibliography
    	filecolor=magenta,      		% color of file links
		urlcolor=blue,
		bookmarksdepth=4
}
\makeatother
% --- 

% ---
% compila o indice
% ---
\makeindex
% ---

% ---
% Altera as margens padrões
% ---
\setlrmarginsandblock{3cm}{3cm}{*}
\setulmarginsandblock{3cm}{3cm}{*}
\checkandfixthelayout
% ---

% --- 
% Espaçamentos entre linhas e parágrafos 
% --- 

% O tamanho do parágrafo é dado por:
\setlength{\parindent}{1.3cm}

% Controle do espaçamento entre um parágrafo e outro:
\setlength{\parskip}{0.2cm}  % tente também \onelineskip

% Espaçamento simples
\SingleSpacing

% ----
% Início do documento
% ----
\begin{document}
% Retira espaço extra obsoleto entre as frases.


% ----------------------------------------------------------
% ELEMENTOS PRÉ-TEXTUAIS
% ----------------------------------------------------------

%---
%
% Se desejar escrever o artigo em duas colunas, descomente a linha abaixo
% e a linha com o texto ``FIM DE ARTIGO EM DUAS COLUNAS''.
% \twocolumn[    		% INICIO DE ARTIGO EM DUAS COLUNAS
%
%---
% página de titulo
\maketitle
\frenchspacing 


% ]  				% FIM DE ARTIGO EM DUAS COLUNAS
% ---

% ----------------------------------------------------------
% ELEMENTOS TEXTUAIS
% ----------------------------------------------------------
\textual

% ----------------------------------------------------------
% Introdução
% ----------------------------------------------------------
\section*{Introdução}
\addcontentsline{toc}{section}{Introdução}
Este trabalho apresenta o resultados obtidos durante o desenvolvimento da
segunda lista de exercícios propostos pelo professor Pedro Pedrosa no curso de
mestrado em Ciências da Computação do IFCE. Parte do código fonte é exibido na
forma de Apêndice ao fim do trabalho. O código fonte detalhado será enviado
junto ao trabalho. 

% ---------------------------------------------------------- Seção de
% explicações ----------------------------------------------------------
\section{Translação, Rotação e Redimensionamento: Tópico 11}
Transção, Rotação e Redimensionamento são transformações lineares que podem ser
aplicadas a um ponto, linha ou qualquer forma representável por um hiperplano.
A forma original do objeto é comumente chamada de pré imagem e após as
transformações realizadas na forma ou no posicionamento do objeto é simplesmente
chamada de imagem.
Os tipos de transformações que foram supracitados possuem uma característica
entre si. Não importa a ordem de aplicação ou mesmo a intensidade dela, sempre
será possível recuperar a forma original a partir da combinação das mesmas três
transformações. Os códigos fonte utilizados nesta sessão encontram-se no
Apendice \ref{apend:transRotRed}.
 
\subsection{Translação}
A operação de tranlação move cada ponto da forma em um fator constante em uma
direção específica. A forma do objeto não sofre qualquer alteração com essa
transformação, apenas o posicionamento no espaço. A translação pode ser vista e
interpretada como a adição de vetores constantes a cada ponto da forma ou como o
deslocamento do centro de coordenadas.
A ideia de se transladar um ponto de coordenadas $(x,y)$ é calcular a nova
posição $(x',y')$ onde $(x',y')=(x+x_0,y+y_0)$ onde $x_0$ e $y_0$ é a
quantidade transladada em cada eixo da coordenada ou simplesmente a nova coordenada da
origem.
Apesar de ser exibido a translação apenas para duas coordenadas esta operação
pode ser feita em qualquer número de dimensões.
A translação pode ser expressa de forma matricial. Abaixo temos a representação
para a translação de uma forma geométrica em um espaço de três dimensões. De
forma generalizada, para qualquer número de dimensões, podemos pensar na matriz
de transformação em que todos os elementos da diagonal principal possuem o
valor 1 e a última coluna com os valores da nova origem de coordenadas.

\begin{align}
Im'=T*Im\\
Im'=\begin{bmatrix}
1 & 0 & 0 & x_0\\
0 & 1 & 0 & y_0\\
0 & 0 & 1 & z_0\\
0 & 0 & 0 & 1\\
\end{bmatrix}*
\begin{bmatrix}
x\\
y\\
z\\
1\\
\end{bmatrix}
\end{align}
Na figura \ref{fig:translacao} temos o resultado da translação na imagem.

\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/imageScale1.png}
                \caption{}
                \label{fig:TransOriginal}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/imageT1.png}
				\caption{}
                \label{fig:TransT1}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/imageT2.png}
                \caption{}
                \label{fig:TransT2}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/imageT3.png}
                \caption{}
                \label{fig:TransT3}       
        \end{subfigure}
        \caption{ \ref{fig:TransOriginal}. Image original
        \ref{fig:TransT1}. Imagem com translação verticalde 50 pixels
        \ref{fig:TransT2}. Imagem com translação horizontal  de 50 pixels
        \ref{fig:TransT3}. Imagem com translação vertical e horizontal de 50
        pixels}
        \label{fig:translacao}
\end{figure}

\subsection{Rotação}
A operação de rotação é uma tranformação geométrica que mapeia a posição de uma
forma em um espaço levando em consideração o ângulo desejado na transformação.
Todos os pontos da forma são rotacionados a partir de um ângulo constante em
relação ao ponto de rotação, para rotação no $\Re^2$, reta no $\Re^3$ ou
hiperplano para o $R^n$.
No $R^2$ os pontos de destino da forma podem ser calculados através das
seguintes equações:
\begin{align}
x'=cos(\theta)*(x_1-x_0)-sen(\theta)*(y_1-y_0)+x_0\\
y'=sen(\theta)*(x_1-x_0)+cos(\theta)*(y_1-y_0)+y_0\\
\end{align}
ou em termos matriciais.
\begin{align}
Im'=T*Im\\
Im'=\begin{bmatrix}
cos(\theta) & sen(\theta)\\
-sen(\theta) & cos(\theta)\\
\end{bmatrix}*
\begin{bmatrix}
x\\
y\\
\end{bmatrix}
\end{align}
Ao fazer uso da forma matricial deve-se perceber que a rotação ocorrerá somente
sobre a origem. Para contornar esta característica faz-se necessário o uso do
operador de translação, deslocando assim o ponto desejado para o centro das
coordenadas para só então realizar a rotação. Na figura \ref{fig:rotacao}
podemos ver o resultado da rotação.

\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/imageScale1.png}
                \caption{}
                \label{fig:RotOriginal}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/image30.png}
				\caption{}
                \label{fig:rot1}

        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/image60.png}
                \caption{}
                \label{fig:rot2}

        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth]{imagens/ex1/image90.png}
                \caption{}
                \label{fig:rot3}       
        \end{subfigure}
        \caption{ \ref{fig:RotOriginal}. Image original
        \ref{fig:rot1}. Imagem com rotação de 30º
        \ref{fig:rot2}. Imagem com rotação de 60º
        \ref{fig:rot3}. Imagem com rotação de 90º
        }
        \label{fig:rotacao}
\end{figure}


\subsection{Redimensionamento}
O redimensionamento é uma transformação linear que aumenta ou diminue o tamanho
de uma forma em um fator constante em todas as direções da forma. Normalmente
este aumento ou redução é feita de forma uniforme, mas pode ser feita de forma
diferente em cada eixo da representação da forma. Um fator de redimencionamento
maior que 1 reflete em um aumento na imagem, menor que 1 em uma redução e um
fator igual a 1 não é feita nenhuma tranformação. É importante ressaltar que
valores menor que 0 não são válidos.
Bem como as operações de translação e rotação o redimencionamento também pode
ser representado por um produto matricial. O redimensionamento de um vetor
$\overleftarrow{v}=(x,y,z)$ por um fator $f$ resulta em um vetor
$\overleftarrow{w}=(fx,fy,fz)$, representado matricialmente por:

\begin{align}
Im'=T*Im\\
 Im' = 
\begin{bmatrix}
f_x & 0 & 0  \\
0 & f_y & 0  \\
0 & 0 & f_z  \\
\end{bmatrix}*
\begin{bmatrix}
x\\
y\\
z\\
\end{bmatrix}
\end{align}

$f_x,f_y,f_z$ são os fatores de redimensionamento para cada dimensão do vetor.

\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{imagens/ex1/imageScale1.png}
                \caption{}
                \label{fig:RedOriginal}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{imagens/ex1/imageScale2.png}
                \caption{}
                \label{fig:Red2}
        \end{subfigure}
        ~
        \begin{subfigure}[b]{0.3\textwidth}
  				\includegraphics[width=\textwidth,scale=1]{imagens/ex1/imageScale3.png}
                \caption{}
                \label{fig:Red3}   
        \end{subfigure}
        \caption{ 
        \ref{fig:RedOriginal}. Image original
        \ref{fig:Red2}. Redimensionamento com fator 1.5
        \ref{fig:Red3}. Redimensionamento com fator 2
        }
        \label{fig:redimensionamento}
\end{figure}

\section{Contrate, Brilho e Gama: Tópico 12}
As técnicas de modificação de histograma são conhecidas como técnicas ponto-a-ponto, uma
vez que o valor de tom de cinza de um certo pixel após o processamento depende apenas de seu
valor original. Dentre as principais técnicas temos o ajuste de brilho,
contraste e gama.

\subsection{Brilho}
O Brilho é um atributo de percepção visual no qual determina a intensidade de
energia emitida ou refletida por uma fonte, O brilho é uma característica
importante pois é ela que determina se a quantidade de luz é perceptível pelos
sensores ou pela aplicação. O ajuste de intensidade do brilho é feito a partir
da seguinte equação:
\begin{align}
Im'(x,y) = Im(x,y) + b
\end{align}
onde b é o valor de ajuste do brilho.


\subsection{Contraste}
O contrate é um atributo que permite que objetos sejam discriminados dentro de
um mesmo campo visual. Dois objetos com intensidades semelhantes são
dificilmentes distinguidos por sensores como o olho humano. O ajuste no
contraste tem como princípio aumentar a diferença de intensidade entre os
objetos.

\begin{align}
Im'(x,y) = c * Im(x,y)
\end{align}
onde c é o valor de ajuste do contraste.

\begin{figure}
\centering
		\begin{tikzpicture}[domain=0:255,scale=0.015]
		\begin{scope}                           % scope environment
			\clip  (-50,-10) rectangle (320,320);
			\draw[->] (-0,0) -- (255,0) node[above] {$x$};
			\draw[->] (0,-0) -- (0,255) node[above] {$f(x)$};
			\draw[color=red, domain=0:137] plot (\x,1.5*\x + 50) node[right] {};
			\draw[color=red, domain=137:255] plot (\x,255) node[right] {$f(x) = x$};
		\end{scope}
		\end{tikzpicture}
		\caption{Função de mapeamento com brilho=50 e contraste=1.5}
\end{figure}
~
\begin{figure}
\centering
	\begin{tikzpicture}[domain=0:255,scale=0.015]
		\begin{scope}                           % scope environment
			\clip  (-50,-10) rectangle (320,320);
			\draw[->] (-0,0) -- (255,0) node[above] {$x$};
			\draw[->] (0,-0) -- (0,255) node[above] {$f(x)$};
			\draw[color=red, domain=20:122] plot (\x,2.5 * \x - 50) node[right] {};
			\draw[color=red, domain=122:255] plot (\x,255) node[right] {$f(x) = x$};
			\draw[color=red, domain=0:20] plot (\x,0) node[right] {};
		\end{scope}           
	\end{tikzpicture}
	\caption{Função de mapeamento com brilho=-50 e contraste=2.5}
\end{figure}

\subsection{Gama}
O gama, assim como o ajuste de contraste é utilizado para aumentar a diferença
de intensidade entre os objetos porem de forma não linear. A regulação do gama
pode ser feita com base na seguinte função.
\begin{align}
Im'(x,y) = c * Im(x,y)^\gamma
\end{align}
onde c é um fator de correção do gama e $\gamma$ é o fator de gama. O fator de
correção é importante pois geralmente o função descrita acima retorna valores
muito altos.
\begin{figure}
\centering
		\begin{tikzpicture}[domain=0:255,scale=0.015]
		\begin{scope}                           % scope environment
			\clip  (-50,-10) rectangle (320,320);
			\draw[->] (-0,0) -- (255,0) node[above] {$x$};
			\draw[->] (0,-0) -- (0,255) node[above] {$f(x)$};
			\draw[color=red, domain=0:255] plot (\x,\x^1) node[above] { };
			\draw[color=blue, domain=0:255] plot (\x,16*\x^0.5) node[below] { };
			\draw[color=yellow, domain=0:25] plot ( 10 * \x, 0.4 * \x^2 ) node[above]{};
			
		\end{scope}
		\end{tikzpicture} 
		\caption{Função de mapeamento do gama. vermelho, azul e amarelo possuem 1,
		0,5 e 2 valores de gama respectivamente}
\end{figure}

\subsection{Resultado Obtidos}

\begin{figure} 
		\centering
		\includegraphics[width=0.3\textwidth,scale=1]{\matlabCodePath
		Trabalho_PDI/bd/pirate.png}
		\caption{Imagem utilizada como teste para as operação de brilho, contraste e
		gama}
		\label{fig:BrilhoContGamaOriginal}
\end{figure}

\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{\matlabCodePath
		Trabalho_PDI/q12/brilhoContrasteGama.eps}
		\caption{Resultado da aplicação das técnicas de ajuste de histograma.
		a)Contraste aplicado 2
		b)Contraste aplicado 0.5
		c)Brilho aplicado 25
		d)Brilho aplicado -25
		e)Gama aplicado 2
		f)Gama aplicado 0.5 
		}
		\label{fig:brilhContGamaRes}		
\end{figure}

Na figura \ref{fig:brilhContGamaRes} temos os resultados obtidos após a
realização de uma série de ajustes na figura \ref{fig:BrilhoContGamaOriginal}.
Podemos perceber através dos histogramas que a alteração do contraste
\ref{fig:brilhContGamaRes} a,b,  faz com que o hisograma seja alongado ou
comprimido ao longo dos possíveis valores da imagem. Diferentemente do ajuste
de contraste, o brilho apenas desloca o histograma,
figura \ref{fig:brilhContGamaRes} c,d. Caso o valor do brilho seja positivo o
histograma é deslocado para a região mas clara, caso negativo para a região mais
escura. O ajuste de gama,figura \ref{fig:brilhContGamaRes} e,f, é um pouco mais
peculiar que os dois anteriores. Por ser uma operação exponencial, caso o valor seja maior que 1 a imagem como um
todo terá a intensidade de seus pixels reduzidas, porém os pixels com valores de
intensidade menor serão ainda mais afetados pelo operador. caso o valor seja
menor que 1 a intensidade da imagem aumentará e da mesma forma os pixels com
valores de intensidade menor sofrerão maiores mudanças. O código fonte deste
exemplo pode ser visualizado no Apendice \ref{apend:contBriGama}


\section{Filtragem no domínio da frequência: Tópico 13 e 14}
A transformada de Fourier é uma transformação matemática que permite que funções
possam ser expressas em componentes senoidais. O somatório destas componentes
tem como resultado a função orignal. A informação de frequencia destas
componentes são muito importantes tendo em vista que com elas podemos
identificar e filtrar ruídos que atuam em frequencias conhecidas. Também pode-se
fazer a filtragem de componentes de maiores ou menores frequencias a partir de
um limiar, filtros passa-baixa e filtros passa-alta respectivamente.

Para um sinal de uma dimensão temos a seguinte equação utilizada para calcular a
transforda de fourier de $s(t)$:
\begin{align}
S(f) = \int_{-\infty}^{\infty} s(t) \cdot e^{-i 2\pi f t} dt.
\end{align}
Para duas dimensões temos a seguinte equação:
\begin{align}
\displaystyle \hat{f}(\xi_x, \xi_y)=
\displaystyle \iint f(x,y) e^{-2\pi i(\xi_x x+\xi_y y)}\,dx\,dy
\end{align}

$\xi_x$ e $\xi_y$ são as frequências calculadas sobre a imagem.
À medida que nos aproximamos da origem da transformada, imagem calculada a
partir da equação anterior, as baixas frequências correspondem aos componentes
de intensidade de variação lenta em uma imagem como mudanças suaves de
intensidade na parede ou em outras regiões uniformes da imagem.
À medida que nos distanciamos da origem da transformada, as frequências mais
altas começam a corresponder a variações de intensidade cada vez mais rápidas
como bordas de objetos e outros elementos, figura
\ref{fig:lenaOriginalEspectro}.
De acordo com as características citadas anteriormente podemos contruir as
matrizes para a filtragem  no dominio da frequencia, figura
\ref{fig:filtrosFrequencia}. Uma das características do domínio da frequência é
que a filtragem espacial pode ser realizada utilizando apenas um produto de
matrizes. O resultado da filtragem pode ser visualizado na figura. O código
fonte utilizado encontra-se no Apêndice \ref{apend:filtragemCod}.


\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{imagens/ex2/lena.png}
                \caption{}
                \label{fig:lenaOriginal}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/espectroOriginal.png}
                \caption{}
                \label{fig:especOriginal}
        \end{subfigure}
       
        \caption{ 
        \ref{fig:lenaOriginal}. Image original
        \ref{fig:especOriginal}. Espectro de Fourier da imagem.
        }
		\label{fig:lenaOriginalEspectro}
\end{figure}

\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/passaBaixa.png}
                \caption{}
                \label{fig:passaBaixa}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/passaAlta.png}
                \caption{}
                \label{fig:passaAlta}
        \end{subfigure}
       
        \caption{ 
        \ref{fig:passaBaixa}. Filtro passa baixa.
        \ref{fig:passaAlta}. Filtro passa alta. 
        }
	\label{fig:filtrosFrequencia}
\end{figure}

\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth} 
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/filtradaPBSpec.png}
                \caption{}
                \label{fig:passaBaixa}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/filtradaPASpec.png}
                \caption{}
                \label{fig:passaAlta}
        \end{subfigure}
 		~      
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/filtradaPB.png}
                \caption{}
                \label{fig:passaBaixa} 
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q13-q14/filtradaPA.png}
                \caption{}
                \label{fig:passaAlta}
        \end{subfigure}      
      
        \caption{ 
        \ref{fig:passaBaixa}. Filtro passa baixa.
        \ref{fig:passaAlta}. Filtro passa alta.
        }
	\label{fig:filtrosFrequencia}
\end{figure}

\section{Segmentação Baseada em cores}

\subsection{Espaço de cores RGB}
O espaço de cores RGB é formado por todas as combinações possíveis das cores
R(Red), G(Green) e B(Blue), vermelho, verde e azul respectivamente. Esse espaço
de cores é normalmente representado por um cubo onde cada eixo representa uma
das componetes,ou canais, de cor, a intensidade de cada componente
indica a cor resultante, figura \ref{subfig:cuboRGB}.
Em imagens coloridas baseadas nesta representação o valor máximo de cada
componente é 255. Na figura \ref{fig:rgbComb} temos o resultado de algumas
combinações deste espaço de cores. Neste espaço de cores, vale ressaltar que a
cor branca é formada pela combinação da máxima intensidade de todas as três componentes, a cor preta
pela combinação da intensidade mínima das três componentes.


\begin{figure} 
		\centering
		\includegraphics[width=0.3\textwidth,scale=1]{imagens/ex4/RGB_combinacao.png}
        \caption{Algumas combinações possíves do espaço de cores RGB. Perceba
        que na interseção das cores são produzidas cores diferentes.}
        \label{fig:rgbComb}
\end{figure}
        
        
\subsection{Espaço de cores HSV} 
O espaço de cores HSV também conhecido como HSB, assim como o RGB possue 3
componentes para representar as cores. As três componentes estão organizadas de forma que suas componentes
armazenem informação da matiz, saturação e brilho separadamente. O lugar
geométrico deste espaço de cores é um cilindro, as vezes também representado por
um cone, onde a altura é o nível de brilho, o raio a intensidade da cor e o
ângulo a cor no espectro luminoso, matiz.
A matiz, componente H, descreve a cor encontrada no espectro eletromagnético, é
dessa componente que descrevemos as cores eg. vermelho, verde, laranja. A
saturação, componente S, descreve a puresa da cor em relação a cor branca. Uma
cor totalmente impura, valor mínimo desta componente, tem como cor resultante a cor branca.
A última componente V ou B, o brilho, descreve quanta luz é emitida do objeto.
A conversão entre os espaços de cores HSV e RGB pode ser feita facilmente com os
seguintes comandos no Matlab. 


\begin{lstlisting}[frame=single, numbers=left]
	% Converter RGB para HSV 
	hsv_image = rgb2hsv(rgb_image)
	% Converter HSV para RGB
	rgb_image = hsv2rgb(hsv_image)
\end{lstlisting}

No Matlab, por padrão as imagens coloridas são alocadas em matrizes onde cada
canal representa uma das componentes do RGB. Cada elemento da matriz representa
uma componente de um pixel da imagem com valores variando entre [0, 255]. Após a
conversão da imagem para o formato HSV as matrizes de cada componente têm seus
valores variando entre [0, 1].

\begin{figure}
		\centering
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{imagens/ex4/rgbColorspace.png}
                \caption{}
                \label{subfig:cuboRGB}
                
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
          %(or a blank line to force the subfigure onto a new line)
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{imagens/ex4/HSVColorSpace.png}
                \caption{}
                \label{subfig:cilindoHSV}
        \end{subfigure}
        
        \caption{ 
        \ref{subfig:cuboRGB}. Representação do espaço de cores RGB
        \ref{subfig:cilindoHSV}. Representação do espaço de cores HSV.
        } 
	\label{fig:filtrosFrequencia}
\end{figure}

\subsection{Segmentação baseada na cor da pele: Tópico 16}
A definição do limiar de segmentação baseado em cores é feita utilizando o
espaço de cores HSV. Como dito anteriormente este espaço de cores possui como
característica a separação da informação de cor de outras informações como
luminosidade e pureza. A figura \ref{fig:skinSegment}a foi utilizada para a
definição dos limiares. Foi verificado que os valores H que melhores descrevem
os tons da pele estão no intervalo [0 , 0.1], intervalo este que representa
10\% da faixa de valores possíveis do canal H. Foi verificado também que para o
canal S os valores que melhor representam o tom da pele estão na faixa de [0.4
1 0.8]. O resultado da combinação dos dois limiares em S e H com a imagem de
entrada pode ser visualizado na imagem \ref{fig:skinSegment}d.  O código
fonte utilizado encontra-se no Apêndice \ref{apend:skinSegment}.


\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{\matlabCodePath
		Trabalho_PDI/skin/skinResult.eps}
		\caption{Resultado da aplicação das técnicas de segmentação.
		a)Imagem Original
		b)Filtro aplicado ao canal H.
		c)Filtro aplicado ao canal H e S
		d)Imagem resultante após os filtros.
		}
		\label{fig:skinSegment}		
\end{figure}

\subsection{Rastreamento baseado em cor: Tópico 17 e 19}
Da mesma forma que a sessão anterior foi feito a segmentação dos objetos baseada
nas cores dos mesmos. Na figura \ref{fig:redBall} temos os objetos encontrados,
três bolas vermelhas. Cada objeto tem como identificador o centróide do objeto.
A identificação foi feita através da cobinação de métodos de multi-limiarização,
segmentação e contorno. Para esta atividade foi utilizado o Opencv. O código
fonte encontra-se no Apendice \ref{apend:rast}.



\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{imagens/track/redBall.png}
		\caption{Rastreamento de objetos conectados baseado na cor.
		}
		\label{fig:redBall}		
\end{figure}



\section{Transformada Haar: Tópico 15}

A maneira mais facil dentre as transformadas Wavelets disponível temos a
transformada Haar(HWT).
A transformada Haar é uma matrz ortogonal, logo $H^{-1}=H^{T}$, utilizada para
calcular cada uma das componentes Wavelets, a saber: Vertical, horizonta,
diagonal e aproximação. Abaixo temos a definição matemática da matriz de Haar.

\begin{align}
H_{N} = 
\begin{bmatrix} 
	\sqrt{2}/2 & \sqrt{2}/2 & 0 & 0 & 0 & 0 &...\\
	 0 & 0 & \sqrt{2}/2 & \sqrt{2}/2 & 0 & 0 &...\\
	 0 & 0 0 & 0 & 0 & \sqrt{2}/2 & \sqrt{2}/2 &... \\
         ...&...&...&...&...&...&...\\
	-\sqrt{2}/2 & \sqrt{2}/2 & 0 & 0 & 0 & 0 &...\\
	 0 & 0 & -\sqrt{2}/2 & \sqrt{2}/2 & 0 & 0 &...\\
	 0 & 0 0 & 0 & 0 & -\sqrt{2}/2 & \sqrt{2}/2 &... \\
         ...&...&...&...&...&...&...\\
\end{bmatrix}
\label{eq:haarMask}
\end{align}

Como podemos observar as primeiras $N/2$ linhas resultam em uma média ponderada
com fator $\sqrt{2}$ da entrada. As últimas $N/2$ linhas resultam em uma diferença
ponderada da entrada também com fator $\sqrt{2}$.

Na equação \ref{eq:haarMask} temos a definição dos filtros passa baixa na
primeira linha da matriz. $h=(h_0,h_1)=(\sqrt{2}/2,\sqrt{2}/2)$. É importante
que além de realizar a média, esse filtro passa baixa amplia a sua intensidade
em $\sqrt{2}$.

Na equação \ref{eq:haarMask} temos também a definição do filtro passa alta na
linha central da matriz. $g=(g_0,g_1)=(-\sqrt{2}/2,\sqrt{2}/2)$. Fazendo
exatamente o contrário do filtro anterior, esse filtro amplia a intesidade do
sinal apenas se houver valores distintos.

Se a imagem é uma matriz $Im$, com dimensões mxn, temos que garantir que a
imagem possuirá dimensões iguais e de potência de base 2, isso pode ser feito
cortando ou adicionando elementos à matriz.
Então após realizar estes ajustes, a HWT pode ser computada como.
\begin{align}
W_H=H_N*Im*H_M^{T} =
\begin{bmatrix} H \\ G \end{bmatrix}
A
\begin{bmatrix} H^T \\ G^T \end{bmatrix}
=
\begin{bmatrix} HA \\ GA \end{bmatrix}
\begin{bmatrix} H^T \\ G^T \end{bmatrix}
\end{align}
\begin{align}
W_H=
\begin{bmatrix} HAH^T \\ HAG^T \end{bmatrix}
\begin{bmatrix} GAH^T \\ GAG^T \end{bmatrix}
\label{eq:blockHaar}
\end{align}
É importante notar o significa de cada bloco na equação \ref{eq:blockHaar}.
O bloco superior esquerdo calcula a média da imagem pois a matriz H é um filtro
passa baixa, por esse motivo este bloco recebe o nome de componente de
aproximação.
O bloco superior direito é também uma média, porém combinado com um filtro passa
baixa atuando na direção vertical, daí o nome componente vertical.
O bloco inferio esquerdo, assim como o superior direito é uma combinação de
filtros passa baixa e passa alta, desta vez com um filtro passa alta atuando na
direção horizontal.
O bloco inferior direito é uma combinação dos filtros passa alta nas duas
direções, vertical e horizontal, sendo chamado por essa característica de
componente diagonal.
O resultado desta operação e a imagem obtida de cada bloco é exibido na Figura
\ref{fig:haarDec1}.
O código fonte utilizado pode ser visualizado no apêndice \ref{apend:HaarCode}

\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{\matlabCodePath
		Trabalho_PDI/haarComp/level1.eps}
		\caption{Resultado da transformada de Haar na imagem Original, Nível 1.
		a)Componente de aproximação.
		b)Componente de detalhes verticais
		c)Componente de detalhes horizontais
		d)Componente de detalhes diagonais.
		}
		\label{fig:haarDec1}		
\end{figure}
Uma prática comum, principalmente em atividades de compressão de imagem e
reconhecimento de padrões é a reaplicação desta transformada na componente de
aproximação da transformada. Nas figura
\ref{fig:haarDec1}, \ref{fig:haarDec2} e \ref{fig:haarDec3} temos o resultado
destas aplicações sucessivas. perceba que ao longo destas aplicações a imagem de
aproximação tem suas informações distribuidas nas componentes verticais,
horizontais e diagonais. As técnicas de compressão se valem dessa característica
e valores nas componentes que tendem a zero são simplesmente zerados
encaminhados para o codificador. Já em reconhecimento de padrões as informações
presentes nestas componentes podem descrever características específicas dos
objetos.

\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{\matlabCodePath
		Trabalho_PDI/haarComp/level2.eps}
		\caption{Resultado da transformada de Haar aplicada na componente de
		aproximação, figura \ref{fig:haarDec1}a, Nível 2.
		a)Componente de aproximação.
		b)Componente de detalhes verticais
		c)Componente de detalhes horizontais
		d)Componente de detalhes diagonais.
		}
		\label{fig:haarDec2}		
\end{figure}


\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{\matlabCodePath
		Trabalho_PDI/haarComp/level3.eps}
		\caption{Resultado da transformada de Haar aplicada na componente de
		aproximação, figura \ref{fig:haarDec2}a, Nível 3.
		a)Componente de aproximação.
		b)Componente de detalhes verticais
		c)Componente de detalhes horizontais
		d)Componente de detalhes diagonais.
		}
		\label{fig:haarDec3}		
\end{figure}


\section{Morfologia Matemática: Tópico 18}
A palavra Morfologia é originalmente um ramo da biologia que estuda as
formas e estruturas dos animais e plantas. Usamos esta palavra no contexto de
Morforlogia Matemática como um instrumento para extração de componentes
da imagem que sejam úteis para representação e descrição da forma de uma
região, como fronteiras, esqueletos e fecho convexo.

A morfologia matemática é o estudo quantificado da forma e estrutura de
conjuntos de pontos (no caso de imagens, conjunto de pixels), cujo principal
objetivo é revelar a estrutura dos objetos formados pelos pontos através da
transformação dos conjuntos que os modelam. Isto é realizado através de OMs. A
partir desta estreita relação da morfologia matemática com a forma, torna-se
natural aplicá-la como técnica de processamento de imagens (Cardoso, 1999).

   Um elemento estruturante é um conjunto de coordenadas de pixel. Por exemplo,
o elemento cruz é definido por $E=\{(0,0),(-1,0),(1,0),(0,-1),(0,1)\}$.
Uma transformação morfológica requer uma operação não-linear entre a imagem e o
elemento estruturante, o qual desliza sobre a imagem de forma similar a uma
convolução.

Os operadores utilizados no processamento morfológico de imagem formam uma ampla
classe de operadores não-lineares. Porém, todos estes são construídos pela
interação de duas operações básicas: a erosão e a dilatação.

A erosão($\ominus$) de uma imagem $F$ para um dado pixel $x$ é definida como o
valor mínimo da imagem em uma janela definida pelo elemento estruturante, estando a origem do
elmento estruturante na posição de x (Soille, 1999). Por outro lado, a
dilatação($\oplus$) é definida como o valor máximo da imagem em uma janela
definida também por um elemento estruturante. Na figura \ref{subfig:ResCruz},\ref{subfig:RdDireita}
e \ref{subfig:RdDireita} temos o resultado da aplicação para três elementos estruturantes
diferentes \ref{fig:elemEst}. Podemos perceber nos resultados que a mudança do
elemento estruturante provoca uma modificação significante na imagem. O primeiro
elemento estruturante permite que a imagem seja dilatada ou erodida em todos os
sentidos enquanto os dois ultimos atuam somente nas diagonais, uma em cada
direção.

\begin{figure}
		\centering 
        \begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1,interpolate]{\matlabCodePath
                Trabalho_PDI/q18-20/cruz.png}
                \caption{}
                \label{subfig:esCruz}
        \end{subfigure}%
        ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
 		\begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath
		Trabalho_PDI/q18-20/dDireita.png}
                \caption{}
                \label{subfig:dDireita}
        \end{subfigure}
        ~%
		\begin{subfigure}[b]{0.3\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath
		Trabalho_PDI/q18-20/dEsquerda.png}
                \caption{}
                \label{subfig:dEsquerda}
        \end{subfigure}%        
        
        \caption{ 
        \ref{subfig:esCruz}. Elemento estruturante em forma de cruz
        \ref{subfig:dDireita}. Elemento estruturante 135º
        \ref{subfig:dEsquerda}. Elemento estruturante 45º
        }
	\label{fig:elemEst}
\end{figure}






\begin{figure}
		\centering 
        \begin{subfigure}[b]{0.8\textwidth}
                \includegraphics[width=\textwidth,scale=1,interpolate]{\matlabCodePath  Trabalho_PDI/q18-20/cruz.eps}
                \caption{Resultado com elemento estruturante em forma de cruz}
                \label{subfig:ResCruz}
        \end{subfigure}%
        \\
         %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc.
 		\begin{subfigure}[b]{0.8\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath Trabalho_PDI/q18-20/2quad.eps}
                \caption{ Resultado com elemento estruturante 135º}
                \label{subfig:RdDireita}
        \end{subfigure}
        \\
        %
		\begin{subfigure}[b]{0.8\textwidth}
                \includegraphics[width=\textwidth,scale=1]{\matlabCodePath
		Trabalho_PDI/q18-20/1quad.eps}
                \caption{Resultado com elemento struturante 45º}
                \label{subfig:RdEsquerda}
        \end{subfigure}%        
        
        \caption{
        Na primeira coluna das figuras \ref{subfig:ResCruz},
        \ref{subfig:RdDireita} e
        \ref{subfig:RdEsquerda} temos a imagem orinal, ao centro temos o
        resultado da dilatação e na útima coluna o resultado da erosão.
        
        }
	\label{fig:elemEst}
\end{figure}



\begin{align}
A \ominus B = \{x | ( B )_x \cap A \subseteq  A\}
\end{align}

\begin{align}
A \oplus B = \{x | (  B^{-1} )_x \cap A \neq  \emptyset\}
\end{align}


\section{Gradiente Morfologico: Tópico 20}
Esta operação e composta de três outras operações básicas da morfologia: a
dilação, erosão e a subtração e é definida da seguinte forma:

\begin{align}
\beta(A) = (A \oplus B) - (A \ominus B)
\end{align}

O processo destaca as transições entre os níveis de cinza (contornos).O
resultado da operação depende do elemento estruturante utilizado,um elemento
pequeno privilegia contornos delgados.
É interessante notar que a simetria do elemento vai fazer com que o
resultado da operação tenda a depender menos dos aspectos direcionais das
bordas. Na figura \ref{fig:gradMorf} temos o resultado da aplicação do gradiente
morfológico em 2 imagens tons de cinza. O código utilizado nesta implementação
pode ser visualizado no Apêndice \ref{apend:gradMorfCode}

\begin{figure} 
		\centering 
		\includegraphics[width=\textwidth,scale=1, trim =
		4cm 0cm 0cm 1cm,clip]{\matlabCodePath
		Trabalho_PDI/q18-20/gradMorf2.eps}
		\caption{Resultado da aplicação do gradiente morfológico.}
		\label{fig:gradMorf}		
\end{figure}


% ---
% Finaliza a parte no bookmark do PDF, para que se inicie o bookmark na raiz
% ---
\bookmarksetup{startatroot}% 
% ---


\begin{citacao}

\end{citacao}


% ]  				% FIM DE ARTIGO EM DUAS COLUNAS
% ---

% ----------------------------------------------------------
% Referências bibliográficas
% ----------------------------------------------------------
\bibliography{pdi}
Cardoso, E.S.J. (1999), Compressão de Imagens Utilizando
   Decomposições em Multi-resolução Morfológicas, Tese de
   Mestrado, Programa de Engenharia Elétrica, COPPE,
   Universidade Federal do Rio de Janeiro, Rio de Janei-
   ro, 114 p.
   
   Soille, P. (1999): Morphological Image Analysis, Heidelberg:
    Springer-Verlag.
   
Alvarenga, A.V. , Application of morphological operators on the
segmentation and contour detection of ultrasound breast images, Revista
Brasileira de Engenharia Biomédica, v. 19, n. 2, p. 91-101, agosto 2003


 
% ----------------------------------------------------------
% Glossário
% ----------------------------------------------------------
%
% Há diversas soluções prontas para glossário em LaTeX. 
% Consulte o manual do abnTeX2 para obter sugestões.
%
%\glossary

% ----------------------------------------------------------
% Apêndices
% ----------------------------------------------------------

% ---
% Inicia os apêndices
% ---
\begin{apendicesenv} 

% ----------------------------------------------------------
\chapter{Código fonte: Translação, Rotação e Redimensionamento}
\label{apend:transRotRed}

	
 	\lstset{extendedchars=true,inputencoding=utf8/latin1}
 	\lstinputlisting[frame=single,
 					 numbers=left]{\matlabCodePath
 	Trabalho_PDI/q11/topico11.m}



\chapter{Código fonte: Ajuste de Brilho, Contraste e Gama}
\label{apend:contBriGama}

\lstset{extendedchars=true,inputencoding=utf8/latin1}

\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/q12/ajustaBrilho.m}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/q12/ajustaContraste.m}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/q12/ajustaGama.m}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/q12/brilhoContraste.m}



\chapter{Código fonte: Filtragem no domínio da frequência}
\label{apend:filtragemCod}
\lstset{extendedchars=true,inputencoding=utf8/latin1}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/q13-q14/filtragem.m}

\chapter{Código fonte: Segmentação de Pele}
\label{apend:skinSegment}
\lstset{extendedchars=true,inputencoding=utf8/latin1}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/skin/skin.m}

\chapter{Código fonte: Transformada de Haar}
\label{apend:HaarCode}
\lstset{extendedchars=true,inputencoding=utf8/latin1}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/haarComp/teste.m}

\chapter{Código fonte: Gradiente Morfológico}
\label{apend:gradMorfCode}
\lstset{extendedchars=true,inputencoding=utf8/latin1}
\lstinputlisting[frame=single, numbers=left]{\matlabCodePath
Trabalho_PDI/q18-20/run.m}

\chapter{Código fonte: Rastreamento baseado em cor}
\label{apend:rast}
\lstset{extendedchars=true,inputencoding=utf8/latin1,language=java,frame=single,
numbers=left}

\begin{lstlisting}
	public static void detectObjects(Mat srcImage,Mat dstImage){
		Mat edges = new Mat(srcImage.size(),CvType.CV_8U);
		
		Imgproc.Canny(srcImage, edges, 128, 255);
		
		//Encontra objetos conectados na imagem segmentada por Canny
	    List<MatOfPoint> contours = new ArrayList<MatOfPoint>();
	    Imgproc.findContours(edges, contours, new Mat(),
	    			 Imgproc.RETR_LIST,Imgproc.CHAIN_APPROX_SIMPLE);

		for (int i = 0; i < contours.size(); i++) {
			MatOfPoint pts = (MatOfPoint) contours.get(i);
			
			//Filtrando pontos pequenos
			if (pts.rows() < 10)
				continue;
				
			//Filtrando formas quadradas
			Rect rect = Imgproc.boundingRect(contours.get(i));
			float k = Math.abs(1 - rect.width/rect.height);
			if(k>0.1 || rect.height < 30 ) continue;
			
			
			double area = Imgproc.contourArea(pts);
			
			System.out.println(k + "   " + rect);
			// System.out.println(rect.x
			// +","+rect.y+","+rect.height+","+rect.width);
			Point pt1 = new Point(rect.x, rect.y);
			Point pt2 = new Point(rect.x + rect.width, rect.y + rect.height);
			Point center = new Point(rect.x + rect.width / 2, rect.y
					+ rect.height / 2);

			Scalar cor = new Scalar(0, 0, 255);

			Core.rectangle(dstImage, pt1, pt2, cor, 3);

			Core.putText(dstImage, "(" + center.toString() + ")", pt2,
					Core.FONT_HERSHEY_TRIPLEX, 0.5, cor);
		}
	}
\end{lstlisting}

\begin{lstlisting}
	//Realiza a filtragem baseada em cores de acordo com as variáveis globais
	//sValue,Limiar de saturação
	// hueValue e hueWidth, valores do tamanho da janela e do centro 
	//da cor utilizada na filtragem
	 
	public void getFilteredImage(Mat frame,Mat dst) {
		
		if(hsv == null){
			Size d = new Size(frame.cols(), frame.height());
			hsv = new Mat(d, CvType.CV_8UC3);
			
			h = new Mat(d, CvType.CV_8U);
			s = new Mat(d, CvType.CV_8U);
			v = new Mat(d, CvType.CV_8U);
			
			h1 = new Mat(d, CvType.CV_8U);
			h2 = new Mat(d, CvType.CV_8U);
		
		}
		
		
		Imgproc.cvtColor(frame, hsv, Imgproc.COLOR_BGR2HSV);
	    Core.split(hsv, lst);
		
	    h = lst.get(0);
	    s = lst.get(1);
	    v = lst.get(2);
	    
		Imgproc.threshold(v, v, 20, 255, Imgproc.THRESH_BINARY);
		Imgproc.threshold(s, s, sValue, 255, Imgproc.THRESH_BINARY);
		
		
		int ls = hueValue+hueWidth;
		int li = hueValue-hueWidth;
		
		if( li>=0 && ls<=180){
			Core.inRange(h, new Scalar(li),new Scalar(ls), dst);
			System.out.println("^L1 = " + (li) + "     L2=" + (ls));
		}else{
			if( ls > 180){
				Core.inRange(h, new Scalar(ls-180),new Scalar(li), dst);
				Core.bitwise_not(dst, dst);
				System.out.println("^L1 = " + (ls-180) + "     L2=" + (li));
			}else{
				Core.inRange(h, new Scalar(ls),new Scalar(180+li), dst);
				Core.bitwise_not(dst, dst);
				System.out.println("^L1 = " + (ls) + "     L2=" + (180+li));
			}
		}
			
		
		Core.bitwise_and(dst, v, dst);
		Core.bitwise_and(dst, s, dst);

}
\end{lstlisting}

\end{apendicesenv}
% ---

% ----------------------------------------------------------
% Anexos
% ----------------------------------------------------------
\cftinserthook{toc}{AAA}


% ---
% Inicia os anexos
% ---
%\anexos
%\begin{anexosenv}
%\chapter{}
%\end{anexosenv}

\end{document}
